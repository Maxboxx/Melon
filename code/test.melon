
class List<T>
	Node<T>?: next
	T: def
	
	function init(T: def)
		self.next = nil
		self.def = def
	end
	
	function add(T: value)
		guard Node<T>: next = self.next else
			self.next = Node<T>(value)
		end
		
		while next = next.next do
		
		end
		
		next.next = Node<T>(value)
	end
	
	function remove(int: index)
		guard index > 0 else
			if Node<T>: next = self.next then
				self.next = next.next
			else
				self.next = nil
			end
		end
		
		guard Node<T>: prev = self.getNode(index - 1)
		
		if Node<T>: next = prev.next then
			prev.next = next.next
		else
			prev.next = nil
		end
	end
	
	function int: count()
		int: count = 0
		Node<T>?: next = self.next
		
		while Node<T>: n = next do
			count = count + 1
			next = n.next
		end
		
		return count
	end
	
	function T: getValue(int: index)
		guard Node<T>: node = self.getNode(index) else
			return self.def
		end
		
		return node.value
	end
	
	function setValue(int: index, T: value)
		guard Node<T>: node = self.getNode(index)
		node.value = value
	end
	
	function Node<T>?: getNode(int: index)
		int: count = 0
		Node<T>?: next = self.next
		
		while Node<T>: n = next do
			if count == index then
				return n
			end
		
			count = count + 1
			next = n.next
		end
		
		return nil
	end
end

class Node<T>
	T: value
	Node<T>?: next
	
	function init(T: value)
		self.value = value
		self.next  = nil
	end
end

struct Console
	static function log<T>(T: t)
		_debug print t
	end
end

List<int>: intList = List<int>(0)
intList.add(3)
intList.add(6)
intList.add(9)

List<bool>: boolList = List<bool>(false)
boolList.add(true)
boolList.add(false)
boolList.add(true)

for int: i = 0, < intList.count() do
	Console.log(intList.getValue(i))
end

for int: i = 0, < boolList.count() do
	Console.log(boolList.getValue(i))
end

Console.log(intList)
